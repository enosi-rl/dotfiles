# Only add to PATH if $HOME/.npm-global/bin is not already present
if [[ ":$PATH:" != *":$HOME/.npm-global/bin:"* ]]; then
  export PATH="$HOME/.npm-global/bin:$HOME/bin:$HOME/.local/bin:/Applications/Docker.app/Contents/Resources/bin/:$PATH"
fi

source ~/bin/wezterm-shell-integration.sh

# Vi mode
set -o vi

# Use neovim as the editor
export VISUAL=nvim
export EDITOR="$VISUAL"

##
## History
##
HISTFILE=$HOME/.zsh_history
HISTSIZE=10000000
SAVEHIST=10000000

# Don't record certain commands:
HISTORY_IGNORE="(ls|cd|pwd|exit)*"

# Immediately append to history file:
setopt INC_APPEND_HISTORY

# Record timestamp in history:
setopt EXTENDED_HISTORY

# Expire duplicate entries first when trimming history:
setopt HIST_EXPIRE_DUPS_FIRST

# Do not display a line previously found:
setopt HIST_FIND_NO_DUPS

# Delete old recorded entry if new entry is a duplicate:
setopt HIST_IGNORE_ALL_DUPS

# Dont record an entry that was just recorded again:
setopt HIST_IGNORE_DUPS

# Dont record an entry starting with a space:
setopt HIST_IGNORE_SPACE

# Remove superfluous blanks from each command line being added to the history.
setopt HIST_REDUCE_BLANKS

# Dont write duplicate entries in the history file:
setopt HIST_SAVE_NO_DUPS

# Share history between all sessions:
setopt SHARE_HISTORY

# Execute commands using history (e.g.: using !$) immediately:
unsetopt HIST_VERIFY

##
## Antidote - package manager
##
# Set the name of the static .zsh plugins file antidote will generate.
zsh_plugins=${ZDOTDIR:-~}/.zsh_plugins.zsh

# Ensure you have a .zsh_plugins.txt file where you can add plugins.
[[ -f ${zsh_plugins:r}.txt ]] || touch ${zsh_plugins:r}.txt

# Lazy-load antidote.
fpath+=(${ZDOTDIR:-~}/.antidote)
autoload -Uz $fpath[-1]/antidote

# Generate static file in a subshell when .zsh_plugins.txt is updated.
if [[ ! $zsh_plugins -nt ${zsh_plugins:r}.txt ]]; then
  (antidote bundle <${zsh_plugins:r}.txt >|$zsh_plugins)
fi

# Source your static plugins file.
source $zsh_plugins

##
## zsh-syntax-highlighting - https://github.com/zsh-users/zsh-syntax-highlighting
## Add `ianthehenry/zsh-autoquoter` to .zsh_plugins.txt
## add zsh-autoquoter
##
# Broken when ssh tunnelling ZSH_HIGHLIGHT_HIGHLIGHTERS+=(zaq)

##
## zsh-autoquoter - https://github.com/ianthehenry/zsh-autoquoter
##
# Broken when ssh tunnelling ZAQ_PREFIXES=('git commit( [^ ]##)# -[^ -]#m' 'ssh( -[^ ]##)# [^ -][^ ]#')

##
## zsh-vim-mode - https://github.com/softmoth/zsh-vim-mode
##
MODE_CURSOR_VIINS="#ffffff blinking bar"
MODE_CURSOR_REPLACE="$MODE_CURSOR_VIINS #ff0000"
MODE_CURSOR_VICMD="white block"
MODE_CURSOR_SEARCH="#ff00ff steady underline"
MODE_CURSOR_VISUAL="$MODE_CURSOR_VICMD steady bar"
MODE_CURSOR_VLINE="$MODE_CURSOR_VISUAL #00ffff"

##
## Starship
##
eval "$(starship init zsh)"

##
## Pkgx
##
# Default toolsets using pkgx
# pkgx install --silent atuin aws aws-vault colima direnv jq docker docker-compose gh terraform terraform-docs
# pkgx install --silent atuin aws aws-vault direnv jq gh terraform terraform-docs
# source <(pkgx --shellcode)  #docs.pkgx.sh/shellcode

##
## Docker
##
export DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
#export DOCKER_BUILDKIT=1
export DOCKER_DEFAULT_PLATFORM=linux/amd64

# Docker plugins - see https://docs.docker.com/compose/install/linux/#install-the-plugin-manually

##
## Aliases
##
alias cdc='cd ~/code'
alias cdcea='cd ~/code/esna-exempt-supply-aggregator/main/'
alias cdcen='cd ~/code/esna-settlements-notifier/main/'
alias cdch='cd ~/code/historian/main/'
alias cdcs='cd ~/code/syndesi/main/'
alias cdcte='cd ~/code/trade-engine/main/'
alias cdctre='cd ~/code/trade-register/main/'
alias cdctru='cd ~/code/trade-rules/main/'
alias cdp='cd ~/proj'
alias cdpe='cd ~/proj/evolve-reconcile/'
alias cp='cp -i'
alias docker-stop-all='docker container stop $(docker container list -q) && docker container prune -f'
alias ga='git add'
alias gc='git commit'
alias gd='git diff --color-words'
alias gdtl='git difftool'
alias gdtlc='git difftool --cached'
alias gl='git log'
alias glr='git lr'
alias gp='git pull'
alias gprev='git switch -'
alias gr='git restore'
alias gs='git status'
alias gsh='git show'
alias gshn='git show --pretty="" --name-only'
alias ij='/Applications/IntelliJ\ IDEA.app/Contents/MacOS/idea'
alias ll='ls -alF'
alias mv='mv -i'
alias rm='rm -i'
alias vim='nvim'

# ceedee dot dot dot
alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'

## Global - see https://justingarrison.com/blog/2023-06-05-zsh-global-aliases/
alias -g G='| grep'
alias -g H='| head -R'
alias -g L='| less -R'
alias -g M='| mlr cat'
alias -g R='| rg'

# Difft
export DFT_COLOR=always

# Podman
# alias docker=podman

##
## Add AWS auto-complete
##
autoload bashcompinit && bashcompinit
autoload -Uz compinit && compinit
# pkgx doesn't provide a link to the completer :-(
complete -C '/System/Volumes/Data/Users/robert/.pkgx/aws.amazon.com/cli/v2.15.8/venv/bin/aws_completer' aws

# jujitsu - https://jj-vcs.github.io/jj/latest/install-and-setup/#standard_1
# source <(jj util completion zsh)

##
## zoxide - https://github.com/ajeetdsouza/zoxide
##
# eval "$(zoxide init zsh)"

##
## ripgrep
##
export RIPGREP_CONFIG_PATH=~/.ripgreprc

##
## direnv
##
# eval "$(direnv hook zsh)"

export ENOSI_COMMON_DIR=~/code/common

##
## Hermit
##
# Generated by Hermit; START; DO NOT EDIT.
HERMIT_ROOT_BIN="${HERMIT_ROOT_BIN:-"$HOME/bin/hermit"}"
eval "$(test -x $HERMIT_ROOT_BIN && $HERMIT_ROOT_BIN shell-hooks --print --zsh)"
# Generated by Hermit; END; DO NOT EDIT.

##
## Enosi
##
export GOPRIVATE=github.com/enosi

##
## Ruby
##
# Add RVM to PATH for scripting. Make sure this is the last PATH variable change.
# export PATH="$PATH:$HOME/.rvm/bin"

# export PATH="/opt/homebrew/opt/ruby@3.2/bin:$PATH"

##
## fzf
##
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

[ -f ~/bin/fzf-git.sh ] && source ~/bin/fzf-git.sh

# Show in reverse order
export FZF_DEFAULT_OPTS='--height 33% --layout=reverse'

# Add '?' to show preview window for long commands
export FZF_CTRL_R_OPTS="--preview 'echo {}' --preview-window down:3:hidden:wrap --bind '?:toggle-preview'"

# Use 'ctrl-x ctrl-r' to run command immediately
# Doesn't work :-(
# fzf-history-widget-accept() {
#   fzf-history-widget
#   zle accept-line
# }
# zle     -N     fzf-history-widget-accept
# bindkey '^X^R' fzf-history-widget-accept

gco() {
  _fzf_git_each_ref --no-multi | xargs git checkout
}

#compdef gt
###-begin-gt-completions-###
#
# yargs command completion script
#
# Installation: gt completion >> ~/.zshrc
#    or gt completion >> ~/.zprofile on OSX.
#
_gt_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" gt --get-yargs-completions "${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _gt_yargs_completions gt
###-end-gt-completions-###

# # Kubernetes
# # kubectl
# alias k=kubectl
#
# # Copyright 2016 The Kubernetes Authors.
# #
# # Licensed under the Apache License, Version 2.0 (the "License");
# # you may not use this file except in compliance with the License.
# # You may obtain a copy of the License at
# #
# #     http://www.apache.org/licenses/LICENSE-2.0
# #
# # Unless required by applicable law or agreed to in writing, software
# # distributed under the License is distributed on an "AS IS" BASIS,
# # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# # See the License for the specific language governing permissions and
# # limitations under the License.
# #compdef kubectl
# compdef _kubectl kubectl
#
# # zsh completion for kubectl                              -*- shell-script -*-
#
# __kubectl_debug()
# {
#     local file="$BASH_COMP_DEBUG_FILE"
#     if [[ -n ${file} ]]; then
#         echo "$*" >> "${file}"
#     fi
# }
#
# _kubectl()
# {
#     local shellCompDirectiveError=1
#     local shellCompDirectiveNoSpace=2
#     local shellCompDirectiveNoFileComp=4
#     local shellCompDirectiveFilterFileExt=8
#     local shellCompDirectiveFilterDirs=16
#     local shellCompDirectiveKeepOrder=32
#
#     local lastParam lastChar flagPrefix requestComp out directive comp lastComp noSpace keepOrder
#     local -a completions
#
#     __kubectl_debug "\n========= starting completion logic =========="
#     __kubectl_debug "CURRENT: ${CURRENT}, words[*]: ${words[*]}"
#
#     # The user could have moved the cursor backwards on the command-line.
#     # We need to trigger completion from the $CURRENT location, so we need
#     # to truncate the command-line ($words) up to the $CURRENT location.
#     # (We cannot use $CURSOR as its value does not work when a command is an alias.)
#     words=("${=words[1,CURRENT]}")
#     __kubectl_debug "Truncated words[*]: ${words[*]},"
#
#     lastParam=${words[-1]}
#     lastChar=${lastParam[-1]}
#     __kubectl_debug "lastParam: ${lastParam}, lastChar: ${lastChar}"
#
#     # For zsh, when completing a flag with an = (e.g., kubectl -n=<TAB>)
#     # completions must be prefixed with the flag
#     setopt local_options BASH_REMATCH
#     if [[ "${lastParam}" =~ '-.*=' ]]; then
#         # We are dealing with a flag with an =
#         flagPrefix="-P ${BASH_REMATCH}"
#     fi
#
#     # Prepare the command to obtain completions
#     requestComp="${words[1]} __complete ${words[2,-1]}"
#     if [ "${lastChar}" = "" ]; then
#         # If the last parameter is complete (there is a space following it)
#         # We add an extra empty parameter so we can indicate this to the go completion code.
#         __kubectl_debug "Adding extra empty parameter"
#         requestComp="${requestComp} \"\""
#     fi
#
#     __kubectl_debug "About to call: eval ${requestComp}"
#
#     # Use eval to handle any environment variables and such
#     out=$(eval ${requestComp} 2>/dev/null)
#     __kubectl_debug "completion output: ${out}"
#
#     # Extract the directive integer following a : from the last line
#     local lastLine
#     while IFS='\n' read -r line; do
#         lastLine=${line}
#     done < <(printf "%s\n" "${out[@]}")
#     __kubectl_debug "last line: ${lastLine}"
#
#     if [ "${lastLine[1]}" = : ]; then
#         directive=${lastLine[2,-1]}
#         # Remove the directive including the : and the newline
#         local suffix
#         (( suffix=${#lastLine}+2))
#         out=${out[1,-$suffix]}
#     else
#         # There is no directive specified.  Leave $out as is.
#         __kubectl_debug "No directive found.  Setting do default"
#         directive=0
#     fi
#
#     __kubectl_debug "directive: ${directive}"
#     __kubectl_debug "completions: ${out}"
#     __kubectl_debug "flagPrefix: ${flagPrefix}"
#
#     if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then
#         __kubectl_debug "Completion received error. Ignoring completions."
#         return
#     fi
#
#     local activeHelpMarker="_activeHelp_ "
#     local endIndex=${#activeHelpMarker}
#     local startIndex=$((${#activeHelpMarker}+1))
#     local hasActiveHelp=0
#     while IFS='\n' read -r comp; do
#         # Check if this is an activeHelp statement (i.e., prefixed with $activeHelpMarker)
#         if [ "${comp[1,$endIndex]}" = "$activeHelpMarker" ];then
#             __kubectl_debug "ActiveHelp found: $comp"
#             comp="${comp[$startIndex,-1]}"
#             if [ -n "$comp" ]; then
#                 compadd -x "${comp}"
#                 __kubectl_debug "ActiveHelp will need delimiter"
#                 hasActiveHelp=1
#             fi
#
#             continue
#         fi
#
#         if [ -n "$comp" ]; then
#             # If requested, completions are returned with a description.
#             # The description is preceded by a TAB character.
#             # For zsh's _describe, we need to use a : instead of a TAB.
#             # We first need to escape any : as part of the completion itself.
#             comp=${comp//:/\\:}
#
#             local tab="$(printf '\t')"
#             comp=${comp//$tab/:}
#
#             __kubectl_debug "Adding completion: ${comp}"
#             completions+=${comp}
#             lastComp=$comp
#         fi
#     done < <(printf "%s\n" "${out[@]}")
#
#     # Add a delimiter after the activeHelp statements, but only if:
#     # - there are completions following the activeHelp statements, or
#     # - file completion will be performed (so there will be choices after the activeHelp)
#     if [ $hasActiveHelp -eq 1 ]; then
#         if [ ${#completions} -ne 0 ] || [ $((directive & shellCompDirectiveNoFileComp)) -eq 0 ]; then
#             __kubectl_debug "Adding activeHelp delimiter"
#             compadd -x "--"
#             hasActiveHelp=0
#         fi
#     fi
#
#     if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then
#         __kubectl_debug "Activating nospace."
#         noSpace="-S ''"
#     fi
#
#     if [ $((directive & shellCompDirectiveKeepOrder)) -ne 0 ]; then
#         __kubectl_debug "Activating keep order."
#         keepOrder="-V"
#     fi
#
#     if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then
#         # File extension filtering
#         local filteringCmd
#         filteringCmd='_files'
#         for filter in ${completions[@]}; do
#             if [ ${filter[1]} != '*' ]; then
#                 # zsh requires a glob pattern to do file filtering
#                 filter="\*.$filter"
#             fi
#             filteringCmd+=" -g $filter"
#         done
#         filteringCmd+=" ${flagPrefix}"
#
#         __kubectl_debug "File filtering command: $filteringCmd"
#         _arguments '*:filename:'"$filteringCmd"
#     elif [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then
#         # File completion for directories only
#         local subdir
#         subdir="${completions[1]}"
#         if [ -n "$subdir" ]; then
#             __kubectl_debug "Listing directories in $subdir"
#             pushd "${subdir}" >/dev/null 2>&1
#         else
#             __kubectl_debug "Listing directories in ."
#         fi
#
#         local result
#         _arguments '*:dirname:_files -/'" ${flagPrefix}"
#         result=$?
#         if [ -n "$subdir" ]; then
#             popd >/dev/null 2>&1
#         fi
#         return $result
#     else
#         __kubectl_debug "Calling _describe"
#         if eval _describe $keepOrder "completions" completions $flagPrefix $noSpace; then
#             __kubectl_debug "_describe found some completions"
#
#             # Return the success of having called _describe
#             return 0
#         else
#             __kubectl_debug "_describe did not find completions."
#             __kubectl_debug "Checking if we should do file completion."
#             if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then
#                 __kubectl_debug "deactivating file completion"
#
#                 # We must return an error code here to let zsh know that there were no
#                 # completions found by _describe; this is what will trigger other
#                 # matching algorithms to attempt to find completions.
#                 # For example zsh can match letters in the middle of words.
#                 return 1
#             else
#                 # Perform file completion
#                 __kubectl_debug "Activating file completion"
#
#                 # We must return the result of this command, so it must be the
#                 # last command, or else we must store its result to return it.
#                 _arguments '*:filename:_files'" ${flagPrefix}"
#             fi
#         fi
#     fi
# }
#
# # don't run the completion function when being source-ed or eval-ed
# if [ "$funcstack[1]" = "_kubectl" ]; then
#     _kubectl
# fi
#
# compdef helm
# compdef _helm helm
#
# # zsh completion for helm                                 -*- shell-script -*-
#
# __helm_debug()
# {
#     local file="$BASH_COMP_DEBUG_FILE"
#     if [[ -n ${file} ]]; then
#         echo "$*" >> "${file}"
#     fi
# }
#
# _helm()
# {
#     local shellCompDirectiveError=1
#     local shellCompDirectiveNoSpace=2
#     local shellCompDirectiveNoFileComp=4
#     local shellCompDirectiveFilterFileExt=8
#     local shellCompDirectiveFilterDirs=16
#     local shellCompDirectiveKeepOrder=32
#
#     local lastParam lastChar flagPrefix requestComp out directive comp lastComp noSpace keepOrder
#     local -a completions
#
#     __helm_debug "\n========= starting completion logic =========="
#     __helm_debug "CURRENT: ${CURRENT}, words[*]: ${words[*]}"
#
#     # The user could have moved the cursor backwards on the command-line.
#     # We need to trigger completion from the $CURRENT location, so we need
#     # to truncate the command-line ($words) up to the $CURRENT location.
#     # (We cannot use $CURSOR as its value does not work when a command is an alias.)
#     words=("${=words[1,CURRENT]}")
#     __helm_debug "Truncated words[*]: ${words[*]},"
#
#     lastParam=${words[-1]}
#     lastChar=${lastParam[-1]}
#     __helm_debug "lastParam: ${lastParam}, lastChar: ${lastChar}"
#
#     # For zsh, when completing a flag with an = (e.g., helm -n=<TAB>)
#     # completions must be prefixed with the flag
#     setopt local_options BASH_REMATCH
#     if [[ "${lastParam}" =~ '-.*=' ]]; then
#         # We are dealing with a flag with an =
#         flagPrefix="-P ${BASH_REMATCH}"
#     fi
#
#     # Prepare the command to obtain completions
#     requestComp="${words[1]} __complete ${words[2,-1]}"
#     if [ "${lastChar}" = "" ]; then
#         # If the last parameter is complete (there is a space following it)
#         # We add an extra empty parameter so we can indicate this to the go completion code.
#         __helm_debug "Adding extra empty parameter"
#         requestComp="${requestComp} \"\""
#     fi
#
#     __helm_debug "About to call: eval ${requestComp}"
#
#     # Use eval to handle any environment variables and such
#     out=$(eval ${requestComp} 2>/dev/null)
#     __helm_debug "completion output: ${out}"
#
#     # Extract the directive integer following a : from the last line
#     local lastLine
#     while IFS='\n' read -r line; do
#         lastLine=${line}
#     done < <(printf "%s\n" "${out[@]}")
#     __helm_debug "last line: ${lastLine}"
#
#     if [ "${lastLine[1]}" = : ]; then
#         directive=${lastLine[2,-1]}
#         # Remove the directive including the : and the newline
#         local suffix
#         (( suffix=${#lastLine}+2))
#         out=${out[1,-$suffix]}
#     else
#         # There is no directive specified.  Leave $out as is.
#         __helm_debug "No directive found.  Setting do default"
#         directive=0
#     fi
#
#     __helm_debug "directive: ${directive}"
#     __helm_debug "completions: ${out}"
#     __helm_debug "flagPrefix: ${flagPrefix}"
#
#     if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then
#         __helm_debug "Completion received error. Ignoring completions."
#         return
#     fi
#
#     local activeHelpMarker="_activeHelp_ "
#     local endIndex=${#activeHelpMarker}
#     local startIndex=$((${#activeHelpMarker}+1))
#     local hasActiveHelp=0
#     while IFS='\n' read -r comp; do
#         # Check if this is an activeHelp statement (i.e., prefixed with $activeHelpMarker)
#         if [ "${comp[1,$endIndex]}" = "$activeHelpMarker" ];then
#             __helm_debug "ActiveHelp found: $comp"
#             comp="${comp[$startIndex,-1]}"
#             if [ -n "$comp" ]; then
#                 compadd -x "${comp}"
#                 __helm_debug "ActiveHelp will need delimiter"
#                 hasActiveHelp=1
#             fi
#
#             continue
#         fi
#
#         if [ -n "$comp" ]; then
#             # If requested, completions are returned with a description.
#             # The description is preceded by a TAB character.
#             # For zsh's _describe, we need to use a : instead of a TAB.
#             # We first need to escape any : as part of the completion itself.
#             comp=${comp//:/\\:}
#
#             local tab="$(printf '\t')"
#             comp=${comp//$tab/:}
#
#             __helm_debug "Adding completion: ${comp}"
#             completions+=${comp}
#             lastComp=$comp
#         fi
#     done < <(printf "%s\n" "${out[@]}")
#
#     # Add a delimiter after the activeHelp statements, but only if:
#     # - there are completions following the activeHelp statements, or
#     # - file completion will be performed (so there will be choices after the activeHelp)
#     if [ $hasActiveHelp -eq 1 ]; then
#         if [ ${#completions} -ne 0 ] || [ $((directive & shellCompDirectiveNoFileComp)) -eq 0 ]; then
#             __helm_debug "Adding activeHelp delimiter"
#             compadd -x "--"
#             hasActiveHelp=0
#         fi
#     fi
#
#     if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then
#         __helm_debug "Activating nospace."
#         noSpace="-S ''"
#     fi
#
#     if [ $((directive & shellCompDirectiveKeepOrder)) -ne 0 ]; then
#         __helm_debug "Activating keep order."
#         keepOrder="-V"
#     fi
#
#     if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then
#         # File extension filtering
#         local filteringCmd
#         filteringCmd='_files'
#         for filter in ${completions[@]}; do
#             if [ ${filter[1]} != '*' ]; then
#                 # zsh requires a glob pattern to do file filtering
#                 filter="\*.$filter"
#             fi
#             filteringCmd+=" -g $filter"
#         done
#         filteringCmd+=" ${flagPrefix}"
#
#         __helm_debug "File filtering command: $filteringCmd"
#         _arguments '*:filename:'"$filteringCmd"
#     elif [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then
#         # File completion for directories only
#         local subdir
#         subdir="${completions[1]}"
#         if [ -n "$subdir" ]; then
#             __helm_debug "Listing directories in $subdir"
#             pushd "${subdir}" >/dev/null 2>&1
#         else
#             __helm_debug "Listing directories in ."
#         fi
#
#         local result
#         _arguments '*:dirname:_files -/'" ${flagPrefix}"
#         result=$?
#         if [ -n "$subdir" ]; then
#             popd >/dev/null 2>&1
#         fi
#         return $result
#     else
#         __helm_debug "Calling _describe"
#         if eval _describe $keepOrder "completions" completions $flagPrefix $noSpace; then
#             __helm_debug "_describe found some completions"
#
#             # Return the success of having called _describe
#             return 0
#         else
#             __helm_debug "_describe did not find completions."
#             __helm_debug "Checking if we should do file completion."
#             if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then
#                 __helm_debug "deactivating file completion"
#
#                 # We must return an error code here to let zsh know that there were no
#                 # completions found by _describe; this is what will trigger other
#                 # matching algorithms to attempt to find completions.
#                 # For example zsh can match letters in the middle of words.
#                 return 1
#             else
#                 # Perform file completion
#                 __helm_debug "Activating file completion"
#
#                 # We must return the result of this command, so it must be the
#                 # last command, or else we must store its result to return it.
#                 _arguments '*:filename:_files'" ${flagPrefix}"
#             fi
#         fi
#     fi
# }

# # don't run the completion function when being source-ed or eval-ed
# if [ "$funcstack[1]" = "_helm" ]; then
#     _helm
# fi
# compdef _helm helm%
eval "$(mise activate zsh)"
